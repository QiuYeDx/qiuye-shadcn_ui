{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-viewer",
  "title": "ImageViewer",
  "type": "registry:component",
  "author": "QiuYeDx <me@qiuyedx.com>",
  "dependencies": [
    "motion",
    "lucide-react"
  ],
  "registryDependencies": [],
  "files": [
    {
      "type": "registry:component",
      "path": "components/qiuye-ui/image-viewer.tsx",
      "content": "\"use client\";\n\nimport React, {\n  useCallback,\n  useEffect,\n  useId,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\nimport { createPortal } from \"react-dom\";\nimport {\n  AnimatePresence,\n  LayoutGroup,\n  motion,\n  useMotionValue,\n} from \"motion/react\";\nimport { animate } from \"motion\";\nimport { ImageIcon } from \"lucide-react\";\nimport { cn } from \"@/lib/utils\";\nimport { usePreventScroll } from \"@/hooks/use-prevent-scroll\";\nimport { useHoverSupport } from \"@/hooks/use-hover-support\";\n\nconst roundedClasses = {\n  none: \"rounded-none\",\n  sm: \"rounded-sm\",\n  md: \"rounded-md\",\n  lg: \"rounded-lg\",\n  xl: \"rounded-xl\",\n  \"2xl\": \"rounded-2xl\",\n  \"3xl\": \"rounded-3xl\",\n  full: \"rounded-full\",\n} as const;\n\ntype RoundedSize = keyof typeof roundedClasses;\n\ntype BaseImageProps = Omit<\n  React.ComponentPropsWithoutRef<\"img\">,\n  | \"src\"\n  | \"onDrag\"\n  | \"onDragStart\"\n  | \"onDragEnd\"\n  | \"onAnimationStart\"\n  | \"onAnimationEnd\"\n  | \"onAnimationIteration\"\n  | \"onAnimationStartCapture\"\n  | \"onAnimationEndCapture\"\n  | \"onAnimationIterationCapture\"\n>;\n\n/** ImageViewer 组件的属性 */\ninterface ImageViewerProps extends BaseImageProps {\n  /**\n   * 图片源地址，支持 URL 字符串或 Blob 对象\n   * - 传入 `string` 时作为 `<img>` 的 `src`\n   * - 传入 `Blob` 时自动通过 `URL.createObjectURL` 创建临时 URL\n   * - 未提供或为空字符串时显示占位符\n   */\n  src?: string | Blob;\n  /**\n   * 缩略图的圆角大小\n   * @default \"lg\"\n   */\n  rounded?: RoundedSize;\n  /**\n   * 灯箱（Lightbox）中图片的圆角大小，未设置时继承 `rounded` 的值\n   */\n  lightboxRounded?: RoundedSize;\n  /**\n   * 缩略图外层容器的自定义 className\n   */\n  wrapperClassName?: string;\n  /**\n   * 灯箱中图片的自定义 className\n   */\n  lightboxClassName?: string;\n  /**\n   * 灯箱遮罩层的自定义 className\n   */\n  overlayClassName?: string;\n  /**\n   * 灯箱遮罩层是否启用背景模糊效果\n   * @default false\n   */\n  overlayBlur?: boolean;\n  /**\n   * 灯箱图片距离视口边缘的最小内边距（像素），最小值为 16\n   * @default 32\n   */\n  lightboxPadding?: number;\n  /**\n   * 是否启用灯箱预览功能，点击缩略图后展开全屏查看\n   * @default true\n   */\n  enableLightbox?: boolean;\n  /**\n   * 非灯箱模式下图片的最大高度\n   * - 传入 `number` 时单位为 px\n   * - 传入 `string` 时作为 CSS 值（如 `\"50vh\"`）\n   */\n  maxHeight?: number | string;\n  /**\n   * 非灯箱模式下图片的最大宽度\n   * - 传入 `number` 时单位为 px\n   * - 传入 `string` 时作为 CSS 值（如 `\"300px\"`）\n   */\n  maxWidth?: number | string;\n  /**\n   * 缩略图鼠标悬浮时的缩放倍数（例如 `1.05` 表示放大 5%），不设置则无悬浮效果\n   */\n  hoverScale?: number;\n  /**\n   * 悬浮动画的弹性系数（0–1），仅在设置 `hoverScale` 时生效\n   * @default 0.25\n   */\n  hoverBounce?: number;\n  /**\n   * 悬浮动画的时长（秒），仅在设置 `hoverScale` 时生效\n   * @default 0.65\n   */\n  hoverDuration?: number;\n  /**\n   * 是否允许用户选中/复制/拖拽图片\n   *\n   * 设为 `false` 时会禁用浏览器原生选中，防止长按等交互触发意外效果\n   * @default false\n   */\n  selectable?: boolean;\n}\n\nconst DEFAULT_PADDING = 32;\nconst MIN_LIGHTBOX_SCALE = 1;\nconst MAX_LIGHTBOX_SCALE = 4;\nconst TOUCH_MOVE_THRESHOLD = 4;\nconst RESET_ANIMATION_DURATION = 0.25; // 灯箱关闭前图片的缩放位移复位的过渡时长\nconst WHEEL_ZOOM_STEP = 0.2;\nconst TRACKPAD_ZOOM_SENSITIVITY = 0.01;\n\nconst clamp = (value: number, min: number, max: number) =>\n  Math.min(Math.max(value, min), max);\n\nconst formatSize = (value: number | string | undefined): string | undefined => {\n  if (value === undefined) return undefined;\n  return typeof value === \"number\" ? `${value}px` : value;\n};\n\nconst getTouchDistance = (touches: React.TouchList) => {\n  const dx = touches[0].clientX - touches[1].clientX;\n  const dy = touches[0].clientY - touches[1].clientY;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nconst getTouchMidpoint = (touches: React.TouchList) => ({\n  x: (touches[0].clientX + touches[1].clientX) / 2,\n  y: (touches[0].clientY + touches[1].clientY) / 2,\n});\n\n/**\n * ImageViewer — 图片查看器组件\n *\n * 提供带灯箱（Lightbox）预览的图片展示，支持：\n * - 点击缩略图打开全屏灯箱，带 `layoutId` 过渡动画\n * - 灯箱内双指捏合缩放（移动端）、鼠标滚轮/触控板缩放（桌面端）\n * - 灯箱内单指/鼠标拖拽平移\n * - 缩略图悬浮缩放动效（可选）\n * - 图片加载骨架屏、加载失败占位符\n * - 支持 `string` URL 或 `Blob` 作为图片源\n *\n * @example\n * ```tsx\n * // 基本用法\n * <ImageViewer src=\"/photo.jpg\" alt=\"示例图片\" />\n *\n * // 禁用灯箱 + 限制最大尺寸\n * <ImageViewer src=\"/photo.jpg\" enableLightbox={false} maxHeight={300} maxWidth=\"50%\" />\n *\n * // 悬浮缩放 + 自定义灯箱圆角 + 背景模糊\n * <ImageViewer src=\"/photo.jpg\" hoverScale={1.03} lightboxRounded=\"xl\" overlayBlur />\n * ```\n */\nexport function ImageViewer({\n  src,\n  alt,\n  title,\n  rounded = \"lg\",\n  lightboxRounded,\n  wrapperClassName,\n  className,\n  lightboxClassName,\n  overlayClassName,\n  overlayBlur = false,\n  lightboxPadding = DEFAULT_PADDING,\n  enableLightbox = true,\n  maxHeight,\n  maxWidth,\n  hoverScale,\n  hoverBounce,\n  hoverDuration = 0.65,\n  selectable = false,\n  loading = \"lazy\",\n  onLoad,\n  onError,\n  ...props\n}: ImageViewerProps) {\n  const [imageError, setImageError] = useState(false);\n  const [imageLoading, setImageLoading] = useState(true);\n  const [isOpen, setIsOpen] = useState(false);\n  const [mounted, setMounted] = useState(false);\n  const [blobUrl, setBlobUrl] = useState<string | null>(null);\n  const imageRef = useRef<HTMLImageElement | null>(null);\n  const lightboxGestureRef = useRef<HTMLDivElement | null>(null);\n  // 灯箱图片的变换使用 MotionValue，避免高频触摸导致重渲染\n  const lightboxScale = useMotionValue(1);\n  const lightboxX = useMotionValue(0);\n  const lightboxY = useMotionValue(0);\n  const pinchStartDistanceRef = useRef(0);\n  const pinchStartScaleRef = useRef(1);\n  const lastTouchPointRef = useRef({ x: 0, y: 0 });\n  const lastMidpointRef = useRef({ x: 0, y: 0 });\n  const isPanningRef = useRef(false);\n  const isMouseDraggingRef = useRef(false);\n  const mouseDragStartRef = useRef({ x: 0, y: 0 });\n  const mousePositionStartRef = useRef({ x: 0, y: 0 });\n  // 关闭流程控制：复位动画期间锁定交互，避免二次触发\n  const isClosingRef = useRef(false);\n  const resetAnimationRef = useRef<null | (() => void)>(null);\n  const resetTimeoutRef = useRef<number | null>(null);\n  const suppressClickRef = useRef(false);\n  const id = useId();\n  const canHover = useHoverSupport();\n\n  const sharedLayoutId = useMemo(() => `image-viewer-${id}`, [id]);\n  const groupId = useMemo(() => `image-viewer-group-${id}`, [id]);\n\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  useEffect(() => {\n    if (src instanceof Blob) {\n      const url = URL.createObjectURL(src);\n      setBlobUrl(url);\n      return () => {\n        URL.revokeObjectURL(url);\n      };\n    }\n    setBlobUrl(null);\n  }, [src]);\n\n  const resolvedSrc = typeof src === \"string\" ? src : blobUrl || undefined;\n  const hasSource =\n    typeof src === \"string\" ? src.trim().length > 0 : src instanceof Blob;\n\n  useEffect(() => {\n    if (resolvedSrc) {\n      setImageLoading(true);\n      setImageError(false);\n    }\n  }, [resolvedSrc]);\n\n  useEffect(() => {\n    if (!resolvedSrc) return;\n    const image = imageRef.current;\n    if (!image) return;\n    if (image.complete) {\n      if (image.naturalWidth === 0) {\n        setImageError(true);\n      }\n      setImageLoading(false);\n    }\n  }, [resolvedSrc]);\n\n  // 预加载图片，确保点击打开灯箱时图片已在浏览器缓存中\n  // 这可以避免首次打开灯箱时因图片加载延迟导致 layoutId 过渡动画异常\n  useEffect(() => {\n    if (!resolvedSrc || !enableLightbox) return;\n\n    const preloadImage = new Image();\n    preloadImage.src = resolvedSrc;\n\n    return () => {\n      // 组件卸载时清理预加载\n      preloadImage.src = \"\";\n    };\n  }, [resolvedSrc, enableLightbox]);\n\n  // 组件卸载时清理复位动画与定时器\n  useEffect(() => {\n    return () => {\n      if (resetAnimationRef.current) {\n        resetAnimationRef.current();\n        resetAnimationRef.current = null;\n      }\n      if (resetTimeoutRef.current !== null) {\n        window.clearTimeout(resetTimeoutRef.current);\n        resetTimeoutRef.current = null;\n      }\n    };\n  }, []);\n\n  // 关闭时先平滑复位，再触发 layoutId 过渡，避免缩放状态影响动画\n  const closeLightbox = useCallback(() => {\n    if (!isOpen || isClosingRef.current) return;\n    const hasTransform =\n      Math.abs(lightboxScale.get() - MIN_LIGHTBOX_SCALE) > 0.01 ||\n      Math.abs(lightboxX.get()) > 0.5 ||\n      Math.abs(lightboxY.get()) > 0.5;\n\n    isPanningRef.current = false;\n    pinchStartDistanceRef.current = 0;\n    suppressClickRef.current = false;\n\n    if (hasTransform) {\n      isClosingRef.current = true;\n      suppressClickRef.current = true;\n\n      if (resetAnimationRef.current) {\n        resetAnimationRef.current();\n        resetAnimationRef.current = null;\n      }\n      if (resetTimeoutRef.current !== null) {\n        window.clearTimeout(resetTimeoutRef.current);\n        resetTimeoutRef.current = null;\n      }\n\n      const controls = [\n        animate(lightboxScale, MIN_LIGHTBOX_SCALE, {\n          duration: RESET_ANIMATION_DURATION,\n          // ease: \"easeOut\",\n          type: \"spring\",\n          bounce: 0,\n        }),\n        animate(lightboxX, 0, {\n          duration: RESET_ANIMATION_DURATION,\n          // ease: \"easeOut\",\n          type: \"spring\",\n          bounce: 0,\n        }),\n        animate(lightboxY, 0, {\n          duration: RESET_ANIMATION_DURATION,\n          // ease: \"easeOut\",\n          type: \"spring\",\n          bounce: 0,\n        }),\n      ];\n\n      resetAnimationRef.current = () => {\n        controls.forEach((control) => control.stop());\n      };\n\n      // 动画结束后再关闭灯箱\n      resetTimeoutRef.current = window.setTimeout(() => {\n        lightboxScale.set(MIN_LIGHTBOX_SCALE);\n        lightboxX.set(0);\n        lightboxY.set(0);\n        resetTimeoutRef.current = null;\n        resetAnimationRef.current = null;\n        isClosingRef.current = false;\n        suppressClickRef.current = false;\n        setIsOpen(false);\n      }, RESET_ANIMATION_DURATION * 1000);\n      return;\n    }\n\n    lightboxScale.set(MIN_LIGHTBOX_SCALE);\n    lightboxX.set(0);\n    lightboxY.set(0);\n    setIsOpen(false);\n  }, [isOpen, lightboxScale, lightboxX, lightboxY]);\n\n  usePreventScroll({\n    enabled: isOpen,\n    onKeyDown: (event) => {\n      if (event.key === \"Escape\") {\n        closeLightbox();\n      }\n    },\n  });\n\n  useEffect(() => {\n    if (!enableLightbox && isOpen) {\n      closeLightbox();\n    }\n  }, [closeLightbox, enableLightbox, isOpen]);\n\n  // 打开时重置状态，防止复位动画残留\n  useEffect(() => {\n    if (!isOpen) return;\n    if (resetAnimationRef.current) {\n      resetAnimationRef.current();\n      resetAnimationRef.current = null;\n    }\n    if (resetTimeoutRef.current !== null) {\n      window.clearTimeout(resetTimeoutRef.current);\n      resetTimeoutRef.current = null;\n    }\n    lightboxScale.set(1);\n    lightboxX.set(0);\n    lightboxY.set(0);\n    isPanningRef.current = false;\n    isMouseDraggingRef.current = false;\n    suppressClickRef.current = false;\n    isClosingRef.current = false;\n  }, [isOpen, lightboxScale, lightboxX, lightboxY]);\n\n  // 避免 Safari 手势缩放影响页面级别缩放\n  useEffect(() => {\n    if (!isOpen) return;\n    const preventGesture = (event: Event) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    document.addEventListener(\"gesturestart\", preventGesture);\n    document.addEventListener(\"gesturechange\", preventGesture);\n    document.addEventListener(\"gestureend\", preventGesture);\n\n    return () => {\n      document.removeEventListener(\"gesturestart\", preventGesture);\n      document.removeEventListener(\"gesturechange\", preventGesture);\n      document.removeEventListener(\"gestureend\", preventGesture);\n    };\n  }, [isOpen]);\n\n  // 触摸手势：单指平移，双指捏合缩放\n  const handleLightboxTouchStart = (event: React.TouchEvent) => {\n    if (isClosingRef.current) return;\n    if (event.touches.length === 1) {\n      const touch = event.touches[0];\n      lastTouchPointRef.current = { x: touch.clientX, y: touch.clientY };\n      isPanningRef.current = lightboxScale.get() > MIN_LIGHTBOX_SCALE;\n      suppressClickRef.current = false;\n    } else if (event.touches.length === 2) {\n      pinchStartDistanceRef.current = getTouchDistance(event.touches);\n      pinchStartScaleRef.current = lightboxScale.get();\n      lastMidpointRef.current = getTouchMidpoint(event.touches);\n      isPanningRef.current = false;\n      suppressClickRef.current = true;\n      event.preventDefault();\n    }\n  };\n\n  const handleLightboxTouchMove = (event: React.TouchEvent) => {\n    if (isClosingRef.current) return;\n    if (event.touches.length === 1 && isPanningRef.current) {\n      const touch = event.touches[0];\n      const deltaX = touch.clientX - lastTouchPointRef.current.x;\n      const deltaY = touch.clientY - lastTouchPointRef.current.y;\n\n      if (\n        Math.abs(deltaX) > TOUCH_MOVE_THRESHOLD ||\n        Math.abs(deltaY) > TOUCH_MOVE_THRESHOLD\n      ) {\n        suppressClickRef.current = true;\n      }\n\n      lightboxX.set(lightboxX.get() + deltaX);\n      lightboxY.set(lightboxY.get() + deltaY);\n      lastTouchPointRef.current = { x: touch.clientX, y: touch.clientY };\n      event.preventDefault();\n      return;\n    }\n\n    if (event.touches.length === 2) {\n      const distance = getTouchDistance(event.touches);\n      if (pinchStartDistanceRef.current === 0) return;\n\n      const nextScale = clamp(\n        pinchStartScaleRef.current * (distance / pinchStartDistanceRef.current),\n        MIN_LIGHTBOX_SCALE,\n        MAX_LIGHTBOX_SCALE\n      );\n\n      const rect = lightboxGestureRef.current?.getBoundingClientRect();\n      const midpoint = getTouchMidpoint(event.touches);\n      const currentScale = lightboxScale.get() || MIN_LIGHTBOX_SCALE;\n      const scaleFactor = nextScale / currentScale;\n      const deltaMidX = midpoint.x - lastMidpointRef.current.x;\n      const deltaMidY = midpoint.y - lastMidpointRef.current.y;\n\n      if (rect) {\n        const offsetX = midpoint.x - rect.left;\n        const offsetY = midpoint.y - rect.top;\n        const currentX = lightboxX.get();\n        const currentY = lightboxY.get();\n\n        lightboxX.set(currentX + deltaMidX + offsetX * (1 - scaleFactor));\n        lightboxY.set(currentY + deltaMidY + offsetY * (1 - scaleFactor));\n      }\n\n      lightboxScale.set(nextScale);\n      lastMidpointRef.current = midpoint;\n      suppressClickRef.current = true;\n      event.preventDefault();\n    }\n  };\n\n  const handleLightboxTouchEnd = (event: React.TouchEvent) => {\n    if (isClosingRef.current) return;\n    if (event.touches.length === 0) {\n      isPanningRef.current = false;\n      pinchStartDistanceRef.current = 0;\n      if (lightboxScale.get() <= MIN_LIGHTBOX_SCALE + 0.01) {\n        lightboxScale.set(MIN_LIGHTBOX_SCALE);\n        lightboxX.set(0);\n        lightboxY.set(0);\n      }\n      return;\n    }\n\n    if (event.touches.length === 1) {\n      const touch = event.touches[0];\n      lastTouchPointRef.current = { x: touch.clientX, y: touch.clientY };\n      isPanningRef.current = lightboxScale.get() > MIN_LIGHTBOX_SCALE;\n    }\n  };\n\n  // 鼠标拖拽移动（仅在缩放后允许）\n  const handleLightboxMouseDown = useCallback(\n    (event: React.MouseEvent) => {\n      if (isClosingRef.current) return;\n      if (event.button !== 0) return;\n      if (lightboxScale.get() <= MIN_LIGHTBOX_SCALE + 0.001) return;\n\n      isMouseDraggingRef.current = true;\n      mouseDragStartRef.current = { x: event.clientX, y: event.clientY };\n      mousePositionStartRef.current = {\n        x: lightboxX.get(),\n        y: lightboxY.get(),\n      };\n      suppressClickRef.current = false;\n      event.preventDefault();\n    },\n    [lightboxScale, lightboxX, lightboxY]\n  );\n\n  // 桌面端滚轮/触控板缩放\n  const handleLightboxWheel = useCallback(\n    (event: React.WheelEvent) => {\n      if (isClosingRef.current) return;\n      event.preventDefault();\n\n      const currentScale = lightboxScale.get();\n      let nextScale = currentScale;\n\n      if (event.ctrlKey) {\n        // 触控板 pinch-to-zoom（带 ctrlKey）\n        const zoomFactor = 1 - event.deltaY * TRACKPAD_ZOOM_SENSITIVITY;\n        nextScale = clamp(\n          currentScale * zoomFactor,\n          MIN_LIGHTBOX_SCALE,\n          MAX_LIGHTBOX_SCALE\n        );\n      } else {\n        // 鼠标滚轮缩放\n        const delta = event.deltaY > 0 ? -WHEEL_ZOOM_STEP : WHEEL_ZOOM_STEP;\n        nextScale = clamp(\n          currentScale + delta,\n          MIN_LIGHTBOX_SCALE,\n          MAX_LIGHTBOX_SCALE\n        );\n      }\n\n      if (Math.abs(nextScale - currentScale) < 0.0001) return;\n\n      if (nextScale <= MIN_LIGHTBOX_SCALE + 0.001) {\n        lightboxScale.set(MIN_LIGHTBOX_SCALE);\n        lightboxX.set(0);\n        lightboxY.set(0);\n        suppressClickRef.current = true;\n        return;\n      }\n\n      const rect = lightboxGestureRef.current?.getBoundingClientRect();\n      if (rect) {\n        const offsetX = event.clientX - rect.left;\n        const offsetY = event.clientY - rect.top;\n        const scaleFactor = nextScale / currentScale;\n        const currentX = lightboxX.get();\n        const currentY = lightboxY.get();\n\n        lightboxX.set(currentX + offsetX * (1 - scaleFactor));\n        lightboxY.set(currentY + offsetY * (1 - scaleFactor));\n      }\n\n      lightboxScale.set(nextScale);\n      suppressClickRef.current = true;\n    },\n    [lightboxScale, lightboxX, lightboxY]\n  );\n\n  // 监听全局鼠标移动/释放，保证拖拽不中断\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleMouseMove = (event: MouseEvent) => {\n      if (isClosingRef.current) return;\n      if (!isMouseDraggingRef.current) return;\n\n      const deltaX = event.clientX - mouseDragStartRef.current.x;\n      const deltaY = event.clientY - mouseDragStartRef.current.y;\n\n      if (\n        Math.abs(deltaX) > TOUCH_MOVE_THRESHOLD ||\n        Math.abs(deltaY) > TOUCH_MOVE_THRESHOLD\n      ) {\n        suppressClickRef.current = true;\n      }\n\n      lightboxX.set(mousePositionStartRef.current.x + deltaX);\n      lightboxY.set(mousePositionStartRef.current.y + deltaY);\n    };\n\n    const handleMouseUp = () => {\n      if (!isMouseDraggingRef.current) return;\n      isMouseDraggingRef.current = false;\n    };\n\n    window.addEventListener(\"mousemove\", handleMouseMove);\n    window.addEventListener(\"mouseup\", handleMouseUp);\n\n    return () => {\n      window.removeEventListener(\"mousemove\", handleMouseMove);\n      window.removeEventListener(\"mouseup\", handleMouseUp);\n    };\n  }, [isOpen, lightboxX, lightboxY]);\n\n  const handleLightboxClick = (event: React.MouseEvent) => {\n    event.stopPropagation();\n    if (suppressClickRef.current) {\n      suppressClickRef.current = false;\n      return;\n    }\n    closeLightbox();\n  };\n\n  if (!hasSource) {\n    return (\n      <span\n        className={cn(\n          \"inline-block my-4 w-full border border-dashed border-muted-foreground/30 bg-muted/20 p-4 text-center text-sm text-muted-foreground\",\n          roundedClasses[rounded],\n          wrapperClassName\n        )}\n      >\n        {alt ? `图片占位: ${alt}` : \"图片链接为空\"}\n      </span>\n    );\n  }\n\n  if (!resolvedSrc) {\n    return (\n      <span\n        className={cn(\n          \"inline-block my-6 w-full overflow-hidden\",\n          roundedClasses[rounded],\n          wrapperClassName\n        )}\n      >\n        <span className=\"flex h-48 w-full items-center justify-center bg-muted/20\">\n          <ImageIcon className=\"h-8 w-8 text-muted-foreground/30\" />\n        </span>\n      </span>\n    );\n  }\n\n  if (imageError) {\n    return (\n      <span\n        className={cn(\n          \"inline-flex w-full flex-col items-center justify-center my-6 p-8 border border-muted-foreground/20 bg-muted/10 text-center\",\n          roundedClasses[rounded],\n          wrapperClassName\n        )}\n      >\n        <ImageIcon className=\"h-12 w-12 text-muted-foreground/40 mb-3\" />\n        <span className=\"text-sm font-medium text-muted-foreground/70 mb-1 block\">\n          图片加载失败\n        </span>\n        {alt && (\n          <span className=\"text-xs text-muted-foreground/50 block\">{alt}</span>\n        )}\n        <span className=\"text-xs text-muted-foreground/40 mt-2 font-mono break-all max-w-full block\">\n          {resolvedSrc}\n        </span>\n      </span>\n    );\n  }\n\n  const inlineRoundedClass = roundedClasses[rounded];\n  const lightboxRoundedClass =\n    roundedClasses[lightboxRounded ?? rounded] ?? roundedClasses.lg;\n  const canPreview = enableLightbox && !imageError;\n  const paddingValue = Math.max(16, lightboxPadding);\n  const maxSizeStyle = {\n    width: `calc(100vw - ${paddingValue * 2}px)`,\n    height: `calc(100vh - ${paddingValue * 2}px)`,\n  };\n\n  return (\n    <LayoutGroup id={groupId}>\n      <span className={cn(\"inline-block my-6 w-full\", wrapperClassName)}>\n        <motion.button\n          type=\"button\"\n          className={cn(\n            \"group relative inline-block max-w-full bg-transparent p-0 text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/40 focus-visible:ring-offset-2 focus-visible:ring-offset-background\",\n            inlineRoundedClass,\n            canPreview ? \"cursor-zoom-in\" : \"cursor-default\"\n          )}\n          whileHover={\n            canHover && hoverScale != null\n              ? {\n                scale: hoverScale,\n                transition: {\n                  type: \"spring\",\n                  bounce: hoverBounce ?? 0.25,\n                  duration: hoverDuration,\n                },\n              }\n              : undefined\n          }\n          whileTap={\n            hoverScale != null\n              ? {\n                scale: 0.97,\n                transition: {\n                  type: \"spring\",\n                  bounce: 0,\n                  duration: hoverDuration * 0.5,\n                },\n              }\n              : undefined\n          }\n          transition={\n            hoverScale != null\n              ? {\n                type: \"spring\",\n                bounce: hoverBounce ?? 0.25,\n                duration: hoverDuration,\n              }\n              : undefined\n          }\n          onClick={() => {\n            if (canPreview) setIsOpen(true);\n          }}\n        >\n          <AnimatePresence>\n            {imageLoading && (\n              <motion.span\n                key=\"image-skeleton\"\n                aria-hidden\n                initial={{ opacity: 1 }}\n                exit={{ opacity: 0 }}\n                transition={{ duration: 0.4, ease: \"easeOut\" }}\n                className={cn(\n                  \"absolute inset-0 z-1\",\n                  inlineRoundedClass\n                )}\n              >\n                <div className={cn(\"h-full w-full bg-accent animate-pulse\", inlineRoundedClass)}></div>\n              </motion.span>\n            )}\n          </AnimatePresence>\n          <motion.img\n            layoutId={sharedLayoutId}\n            ref={imageRef}\n            src={resolvedSrc}\n            alt={alt || \"\"}\n            title={title}\n            draggable={selectable}\n            className={cn(\n              \"block h-auto max-w-full\",\n              !selectable && \"select-none\",\n              inlineRoundedClass,\n              className\n            )}\n            style={{\n              maxHeight: formatSize(maxHeight),\n              maxWidth: formatSize(maxWidth),\n              opacity: imageLoading ? 0 : 1,\n              filter: imageLoading ? \"blur(6px)\" : \"blur(0px)\",\n              transition: \"opacity 0.5s ease-out, filter 0.5s ease-out\",\n              ...(!selectable && { WebkitTouchCallout: \"none\" }),\n            }}\n            loading={loading}\n            onLoad={(event) => {\n              setImageLoading(false);\n              onLoad?.(event);\n            }}\n            onError={(event) => {\n              setImageError(true);\n              setImageLoading(false);\n              onError?.(event);\n            }}\n            {...props}\n          />\n        </motion.button>\n      </span>\n\n      {mounted &&\n        createPortal(\n          <AnimatePresence>\n            {isOpen && (\n              <motion.div\n                className=\"fixed inset-0 z-50 flex items-center justify-center select-none\"\n                role=\"dialog\"\n                aria-modal=\"true\"\n                aria-label={alt ? `查看图片：${alt}` : \"查看图片\"}\n                transition={{ duration: 0.2, ease: \"easeInOut\" }}\n              >\n                <motion.div\n                  className={cn(\n                    \"absolute inset-0 bg-black/60 dark:bg-black/70\",\n                    overlayBlur && \"backdrop-blur-sm\",\n                    overlayClassName\n                  )}\n                  initial={{ opacity: 0 }}\n                  animate={{ opacity: 1 }}\n                  exit={{ opacity: 0 }}\n                  transition={{ duration: 0.5, ease: \"easeOut\" }}\n                  onClick={(event) => {\n                    event.stopPropagation();\n                    closeLightbox();\n                  }}\n                />\n\n                <motion.div\n                  className=\"relative z-10 flex items-center justify-center cursor-zoom-out\"\n                  style={maxSizeStyle}\n                  onClick={handleLightboxClick}\n                >\n                  <motion.div\n                    ref={lightboxGestureRef}\n                    className=\"flex h-full w-full items-center justify-center\"\n                    style={{\n                      x: lightboxX,\n                      y: lightboxY,\n                      scale: lightboxScale,\n                      transformOrigin: \"0 0\",\n                      touchAction: \"none\",\n                    }}\n                    onTouchStart={handleLightboxTouchStart}\n                    onTouchMove={handleLightboxTouchMove}\n                    onTouchEnd={handleLightboxTouchEnd}\n                    onTouchCancel={handleLightboxTouchEnd}\n                    onMouseDown={handleLightboxMouseDown}\n                    onWheel={handleLightboxWheel}\n                  >\n                    <motion.img\n                      layoutId={sharedLayoutId}\n                      src={resolvedSrc}\n                      alt={alt || \"\"}\n                      title={title}\n                      draggable={selectable}\n                      className={cn(\n                        \"h-auto w-auto max-h-full max-w-full object-contain shadow-2xl\",\n                        !selectable && \"select-none\",\n                        lightboxRoundedClass,\n                        lightboxClassName\n                      )}\n                      style={\n                        !selectable\n                          ? { WebkitTouchCallout: \"none\" }\n                          : undefined\n                      }\n                      // 灯箱图片使用 eager 加载，配合预加载确保过渡动画流畅\n                      loading=\"eager\"\n                    />\n                  </motion.div>\n                </motion.div>\n              </motion.div>\n            )}\n          </AnimatePresence>,\n          document.body\n        )}\n    </LayoutGroup>\n  );\n}\n"
    },
    {
      "type": "registry:hook",
      "path": "hooks/use-hover-support.ts",
      "content": "import { useState, useEffect } from \"react\";\n\n/**\n * 检测当前设备的主要输入方式是否支持 hover。\n * 在触屏移动端设备上返回 false，桌面端（鼠标/触控板）返回 true。\n * SSR 安全：服务端渲染时默认返回 false，挂载后根据实际能力更新。\n */\nexport function useHoverSupport(): boolean {\n  const [canHover, setCanHover] = useState(false);\n\n  useEffect(() => {\n    const mql = window.matchMedia(\"(hover: hover)\");\n    const onChange = () => setCanHover(mql.matches);\n\n    setCanHover(mql.matches);\n    mql.addEventListener(\"change\", onChange);\n\n    return () => mql.removeEventListener(\"change\", onChange);\n  }, []);\n\n  return canHover;\n}\n"
    },
    {
      "type": "registry:hook",
      "path": "hooks/use-prevent-scroll.ts",
      "content": "\"use client\";\n\nimport { useEffect } from \"react\";\n\nconst DEFAULT_BLOCKED_KEYS = [\n  \"ArrowUp\",\n  \"ArrowDown\",\n  \"PageUp\",\n  \"PageDown\",\n  \"Home\",\n  \"End\",\n  \" \",\n];\n\nconst defaultIgnoreTarget = (target: EventTarget | null) => {\n  if (!target || !(target instanceof HTMLElement)) return false;\n  const tagName = target.tagName.toLowerCase();\n  return (\n    tagName === \"input\" ||\n    tagName === \"textarea\" ||\n    tagName === \"select\" ||\n    target.isContentEditable\n  );\n};\n\ninterface UsePreventScrollOptions {\n  enabled?: boolean;\n  blockedKeys?: string[];\n  ignoreTarget?: (target: EventTarget | null) => boolean;\n  preventWheel?: boolean;\n  preventTouchMove?: boolean;\n  preventKeyboard?: boolean;\n  onKeyDown?: (event: KeyboardEvent) => void;\n}\n\nexport function usePreventScroll({\n  enabled = true,\n  blockedKeys = DEFAULT_BLOCKED_KEYS,\n  ignoreTarget = defaultIgnoreTarget,\n  preventWheel = true,\n  preventTouchMove = true,\n  preventKeyboard = true,\n  onKeyDown,\n}: UsePreventScrollOptions = {}) {\n  useEffect(() => {\n    if (!enabled) return;\n\n    const preventScroll = (event: Event) => {\n      if (event.cancelable) {\n        event.preventDefault();\n      }\n    };\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      onKeyDown?.(event);\n      if (ignoreTarget(event.target)) return;\n      if (blockedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n    };\n\n    if (preventKeyboard) {\n      window.addEventListener(\"keydown\", handleKeyDown, { passive: false });\n    }\n    if (preventWheel) {\n      window.addEventListener(\"wheel\", preventScroll, { passive: false });\n    }\n    if (preventTouchMove) {\n      window.addEventListener(\"touchmove\", preventScroll, { passive: false });\n    }\n\n    return () => {\n      if (preventKeyboard) {\n        window.removeEventListener(\"keydown\", handleKeyDown);\n      }\n      if (preventWheel) {\n        window.removeEventListener(\"wheel\", preventScroll);\n      }\n      if (preventTouchMove) {\n        window.removeEventListener(\"touchmove\", preventScroll);\n      }\n    };\n  }, [\n    enabled,\n    blockedKeys,\n    ignoreTarget,\n    preventKeyboard,\n    preventWheel,\n    preventTouchMove,\n    onKeyDown,\n  ]);\n}\n"
    }
  ]
}
